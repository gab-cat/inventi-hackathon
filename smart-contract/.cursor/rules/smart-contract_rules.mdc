---
description: Solidity and smart contract security standards for ERC-20/721/1155; enforce secure patterns, testing, and audits.
globs: ["**/*.sol", "foundry.toml", "src/**", "script/**", "test/**", "lib/**"]
alwaysApply: false
---
    Solidity Best Practices
    - Use explicit function visibility modifiers and appropriate natspec comments.
    - Utilize function modifiers for common checks, enhancing readability and reducing redundancy.
    - Follow consistent naming: CamelCase for contracts, PascalCase for interfaces (prefixed with "I").
    - Implement the Interface Segregation Principle for flexible and maintainable contracts.
    - Design upgradeable contracts using proven patterns like the proxy pattern when necessary.
    - Implement comprehensive events for all significant state changes.
    - Follow the Checks-Effects-Interactions pattern to prevent reentrancy and other vulnerabilities.
    - Use static analysis tools like Slither and Mythril in the development workflow.
    - Implement timelocks and multisig controls for sensitive operations in production.
    - Conduct thorough gas optimization, considering both deployment and runtime costs.
    - Use OpenZeppelin's AccessControl for fine-grained permissions.
    - Use Solidity 0.8.0+ for built-in overflow/underflow protection.
    - Implement circuit breakers (pause functionality) using OpenZeppelin's Pausable when appropriate.
    - Use pull over push payment patterns to mitigate reentrancy and denial of service attacks.
    - Implement rate limiting for sensitive functions to prevent abuse.
    - Use OpenZeppelin's SafeERC20 for interacting with ERC20 tokens.
    - Implement proper randomness using Chainlink VRF or similar oracle solutions.
    - Use assembly for gas-intensive operations, but document extensively and use with caution.
    - Implement effective state machine patterns for complex contract logic.
    - Use OpenZeppelin's ReentrancyGuard as an additional layer of protection against reentrancy.
    - Implement proper access control for initializers in upgradeable contracts.
    - Use OpenZeppelin's ERC20Snapshot for token balances requiring historical lookups.
    - Implement timelocks for sensitive operations using OpenZeppelin's TimelockController.
    - Use OpenZeppelin's ERC20Permit for gasless approvals in token contracts.
    - Implement proper slippage protection for DEX-like functionalities.
    - Use OpenZeppelin's ERC20Votes for governance token implementations.
    - Implement effective storage patterns to optimize gas costs (e.g., packing variables).
    - Use libraries for complex operations to reduce contract size and improve reusability.
    - Implement proper access control for self-destruct functionality, if used.
    - Use OpenZeppelin's Address library for safe interactions with external contracts.
    - Use custom errors instead of revert strings for gas efficiency and better error handling.
    - Implement NatSpec comments for all public and external functions.
    - Use immutable variables for values set once at construction time.
    - Implement proper inheritance patterns, favoring composition over deep inheritance chains.
    - Use events for off-chain logging and indexing of important state changes.
    - Implement fallback and receive functions with caution, clearly documenting their purpose.
    - Use view and pure function modifiers appropriately to signal state access patterns.
    - Implement proper decimal handling for financial calculations, using fixed-point arithmetic libraries when necessary.
    - Use assembly sparingly and only when necessary for optimizations, with thorough documentation.
    - Implement effective error propagation patterns in internal functions.

    Gas Efficiency Rules
    - Prefer `x != 0` over `x > 0` for unsigned integers in `if` statements.
    - Payable constructors save ~10 opcodes but can accept ETH; use with caution.
    - Non-strict inequalities (`>=`, `<=`) are cheaper than strict ones (`>`, `<`).
    - Pack multiple bools into a bitmap to save storage (32 per slot vs 1 per bool).
    - Avoid zero-to-non-zero writes (22,100 gas). Use patterns like ReentrancyGuard (1/2 values).
    - `block.timestamp` and `block.number` are automatically added to events; don’t log manually.
    - Mark owner-only functions as `payable` to reduce gas for legit calls.
    - Public `constant` variables are more expensive; prefer inline constants in code.
    - Use `.delete` instead of resetting integers to 0 for cheaper gas.
    - Minimize repeated `SLOAD`s — cache in memory (MLOAD/MSTORE is ~3 gas).
    - Avoid `+=` and `-=` when possible; `x = x + y` is slightly cheaper.
    - Combine multiple mappings into a struct to reduce slot usage and avoid extra `Gsset` (20,000 gas).
    - Skip storage updates if the new value equals the old one (avoid `Gsreset` 2900 gas).
    - Optimize functions like `markGameEnded` by caching frequently used vars (`s_gameEnded`) in memory.

    Testing and Quality Assurance
    - Implement a comprehensive testing strategy including unit, integration, and end-to-end tests.
    - Use property-based testing to uncover edge cases.
    - Implement continuous integration with automated testing and static analysis.
    - Conduct regular security audits and bug bounties for production-grade contracts.
    - Use test coverage tools and aim for high test coverage, especially for critical paths.

    Performance Optimization
    - Optimize contracts for gas efficiency, considering storage layout and function optimization.
    - Implement efficient indexing and querying strategies for off-chain data.

    Development Workflow
    - Utilize Foundry's testing and debugging features.
    - Implement a robust CI/CD pipeline for smart contract deployments.
    - Use static type checking and linting tools in pre-commit hooks.

    Documentation
    - Document code thoroughly, focusing on why rather than what.
    - Maintain up-to-date API documentation for smart contracts.
    - Create and maintain comprehensive project documentation, including architecture diagrams and decision logs.
